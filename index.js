// JavaScript Mastery Challenge
// Письменные задачи
// 1. setImmediate и process.nextTick
// Что выведет следующий код? Объясни почему.
// console.log('Start');
// setImmediate(() => console.log('Immediate'));
// process.nextTick(() => console.log('NextTick'));
// console.log('End');
//Start->End->NextTick->Immediate
// Сначала выполняются синхронный код а это:
// console.log('Start');
// console.log('End');
// Затем выполняется микротаски так как они в приоритете но так как это event loop
// в контексте node.js то имеет и приоритет над другими микротасками и выполняется
// самым первым в стеке микротасок
// process.nextTick(() => console.log('NextTick'));
// А затем переход в макротаски и там дожидаясь I/O операций выполняется
// setImmediate(() => console.log('Immediate'));
// =============================================================================
// Реализуй функцию, которая выполняет асинхронные задачи
// поочерёдно (как цепочка), используя process.nextTick и setImmediate.
// Задача не совсем понятно когда и что использовать но напишу две функции

// function runTaskUseProcessNextTick() {

// }

// function runTaskUseImmediate() {

// }

// const tasksArray = [
// 	(cb) => { console.log('Task 1 started'); cb(); },
// 	(cb) => { console.log('Task 2 started'); cb(); },
// 	(cb) => { console.log('Task 3 started'); cb(); },
// ];

// runTasks(tasksArray);

// function callChain() {
// 	// setImmediate(() => console.log("Immediate"));
// 	// process.nextTick(() => console.log("NextTick"));

// 	new Promise((resolve, reject) => {
// 		setImmediate(() => console.log("Immediate"));
// 		resolve("Выполнился nextTick");
// 	}).then((res) => {
// 		process.nextTick(() => console.log("NextTick"));
// 	});
// }

// callChain();













// =============================================================================
// 2. Math.trunc
// Напиши функцию, которая принимает любое число и возвращает его целую часть, используя только Math.trunc.
// function numberIntegralPart(num) {
// 	return Math.trunc(num);
// }
// =============================================================================
// Как ты можешь округлить число до ближайшего меньшего целого, не используя Math.floor?
// Например возьмем число 15.65
// 15.65 ближайшее ему меньшее число и есть само число т.е 15
// соотвественно достаточно использовать Math.trunc но это работает с положительными числами
// т.е возьмем теперь
// -15.65 ближайшее ему меньшее целое число это -16 и уже не подойдет соотвественно самая легкая реализация
// function numFloor(num) {
// 	return num < 0 ? ((Math.trunc(num * (-1)) + 1) * (-1)) : Math.trunc(num);
// }
// console.log(numFloor(15.65));
// =============================================================================
// 3. ChainableClass
// Создай класс "ChainableCalculator", который позволяет вызывать методы цепочкой и получать результат.
// Пример:
// const calc = new ChainableCalculator();
// calc.add(5).subtract(2).multiply(3).result(); // 9
// class ChainableCalculator {
// 	constructor() {
// 		this._result = 0;
// 	}
// 	add(num) {
// 		this._result = this._result + num;
// 		return this;
// 	}
// 	subtract(num) {
// 		this._result = this._result - num;
// 		return this;
// 	}
// 	multiply(num) {
// 		this._result = this._result * num;
// 		return this;
// 	}
// 	division(num) {
// 		this._result = this._result / num;
// 		return this;
// 	}
// 	result() {
// 		return this._result;
// 	}
// }
// const calc = new ChainableCalculator();
// let x = calc.add(5).subtract(2).multiply(3).result();
// console.log(x)
// =============================================================================
// 4. Object.assign и прототипы
// В чём разница между поверхностным и глубоким копированием объектов? Как это связано с Object.assign?

// Реализуй глубокое копирование объекта без использования JSON.stringify.

// Напиши пример, где использование Object.assign приводит к неожиданным результатам.

// 5. Прототипное наследование
// Как создать объект без прототипа?

// Напиши функцию, которая создаёт новый объект, наследующий свойства другого объекта.

// Объясни разницу между proto и prototype.
// =============================================================================
// 6. Миксины
// Что такое миксин? Для чего он нужен?
// Миксин — это объект или класс, содержащий методы, которые могут быть добавлены в другие классы или объекты. Миксины позволяют "подмешивать" функционал в другие классы, избегая жёсткой наследственной иерархии
// Напиши миксин EventMixin, который добавляет функционал подписки и вызова событий.
class EventMixin


// Как можно сделать миксины безопасными для конфликтующих методов?
// =============================================================================
// 7. Множественное наследование
// Как реализовать множественное наследование в JavaScript?

// Напиши класс, который наследует методы из двух других классов.
// =============================================================================
// 8. Замыкания
// Что такое замыкание? Приведи пример.
// Напиши функцию createCounter, которая создаёт независимый счётчик.
// Как замыкания помогают скрывать внутренние данные?
// При первичном вызове функции создается counter = 0; а дальше мы работаем с данной
// переменной не имея доступа напрямую
// const createCounter = () => {
// 	let counter = 0;
// 	return () => {
// 		counter++;
// 		return counter;
// 	};
// };
// const counter = createCounter();
// console.log(counter());//1
// console.log(counter());//2
// console.log(counter());//3
// =============================================================================
// 9. Proxy
// Что такое Proxy в JavaScript? Для чего он используется?
// Объект Proxy оборачивается вокруг другого объекта и может перехватывать (и, при желании, самостоятельно обрабатывать) разные действия с ним, например чтение/запись свойств и другие
// Реализуй Proxy, который блокирует доступ к свойствам объекта, начинающимся на "_".
// const blockUnderscoreProxy = (target) => {
// 	return new Proxy(target, {
// 		get(obj, prop) {
// 			if (typeof prop === "string" && prop.startsWith("_"))
// 				throw new Error("Доступ к свойству " + prop + " запрещен");
// 			return obj[prop];
// 		},
// 		set(obj, prop, value) {
// 			if (typeof prop === "string" && prop.startsWith("_"))
// 				throw new Error("Запрет на запись свойства " + prop);
// 			obj[prop] = value;
// 			return true;
// 		},
// 		deleteProperty(obj, prop) {
// 			if (typeof prop === "string" && prop.startsWith("_"))
// 				throw new Error("Удаление свойства " + prop + " запрещено");
// 			return delete obj[prop];
// 		}
// 	});
// };
// const obj = {
// 	_secret: 42,
// 	public: "Hello"
// }
// const proxyObj = blockUnderscoreProxy(obj);
// console.log(proxyObj.public);
// // console.log(proxyObj._secret);
// // proxyObj._secret = 43;
// // delete proxyObj._secret;
// Как использовать Proxy для логирования вызовов методов объекта?
// Незнаю если честно...но давай так логически...можно использовать get и перехватывать до выполнения
// и после выполнения кода типа как ловушка и будет работать как декораторы :)
// =============================================================================
// 10. call, apply, bind
// Как работает call, apply и bind? В чём между ними разница?

// Как реализовать собственный метод bind?

// Напиши пример использования call для заимствования метода из другого объекта.
// =============================================================================
// 11. BigInt
// Что такое BigInt? Как он отличается от Number?
// Bigint является в js типом данных и в отличие от Number который юзает
// безопасные числа 2^53 - 1 в данном пределе Bigint ограничен только памятью
// Почему не стоит использовать Math методы с BigInt?
// Math класс преднозначен для работы с типом данных Number
// Реализуй функцию сложения двух BigInt значений.
// function bigIntSum(b1,b2){
// 	big1 = typeof b1 === "bigint" ? b1 : BigInt(b1);
// 	big2 = typeof b2 === "bigint" ? b2 : BigInt(b2);
// 	return big1+big2;
// }
// console.log(bigIntSum(100n,100n));
// =============================================================================










// Устные вопросы
// =============================================================================
// Что такое setImmediate и как оно отличается от process.nextTick?
// process.nextTick - является микротаской и выполняется до всего и вся и стоит как самая приоритетная задача
// ну по крайней мере выше промисов
// setImmediate - является макротаской и выполняется только тогда когда нет задач с I/O и выполняется первее 
// чем timeout или interval
// =============================================================================
// Что произойдёт, если в замыкании изменить переменную из родительской области?
// Так как значение находится в видимости самого замыкания т.е радительской области
// то соответственно значение действительно поменяется и все будет окей
// =============================================================================
// Почему миксины могут создавать конфликты?
// =============================================================================
// В чём разница между Object.create и Object.assign?
// =============================================================================
// Как можно превратить Proxy в мемоизированный объект?
// =============================================================================
// Почему важно знать о prototype и proto?
// =============================================================================
// Что такое полиморфизм и как он реализуется в JavaScript?
// =============================================================================
// Что будет, если мы изменим Array.prototype?
// =============================================================================
// Как работает JSON.stringify с BigInt?
// =============================================================================
// Почему опасно использовать "new" без проверки?
// =============================================================================