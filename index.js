// JavaScript Mastery Challenge
// Письменные задачи
// 1. setImmediate и process.nextTick
// Что выведет следующий код? Объясни почему.
// console.log('Start');
// setImmediate(() => console.log('Immediate'));
// process.nextTick(() => console.log('NextTick'));
// console.log('End');
//Start->End->NextTick->Immediate
// Сначала выполняются синхронный код а это:
// console.log('Start');
// console.log('End');
// Затем выполняется микротаски так как они в приоритете но так как это event loop
// в контексте node.js то имеет и приоритет над другими микротасками и выполняется
// самым первым в стеке микротасок
// process.nextTick(() => console.log('NextTick'));
// А затем переход в макротаски и там дожидаясь I/O операций выполняется
// setImmediate(() => console.log('Immediate'));
// =============================================================================
// Реализуй функцию, которая выполняет асинхронные задачи
// поочерёдно (как цепочка), используя process.nextTick и setImmediate.
// Задача не совсем понятно когда и что использовать но напишу одну функцию через
// индекс который попеременно будет вызывать и то и другое
// function runTasksSequentially(tasks){
// 	let idx = 0;
// 	function next(){
// 		if (idx >= tasks.length) return;
// 		const task = tasks[idx++];
// 		task(()=>{
// 			if(idx % 2 === 0)
// 				process.nextTick(next);
// 			else
// 				setImmediate(next);
// 		});
// 	}
// 	next();
// }
// const tasks = [
// 	(done) => { console.log("Task 1"); done(); },
// 	(done) => { console.log("Task 2"); done(); },
// 	(done) => { console.log("Task 3"); done(); },
// ]
// runTasksSequentially(tasks);
// =============================================================================
// 2. Math.trunc
// Напиши функцию, которая принимает любое число и возвращает его целую часть, используя только Math.trunc.
// function numberIntegralPart(num) {
// 	return Math.trunc(num);
// }
// =============================================================================
// Как ты можешь округлить число до ближайшего меньшего целого, не используя Math.floor?
// Например возьмем число 15.65
// 15.65 ближайшее ему меньшее число и есть само число т.е 15
// соотвественно достаточно использовать Math.trunc но это работает с положительными числами
// т.е возьмем теперь
// -15.65 ближайшее ему меньшее целое число это -16 и уже не подойдет соотвественно самая легкая реализация
// function numFloor(num) {
// 	return num < 0 ? ((Math.trunc(num * (-1)) + 1) * (-1)) : Math.trunc(num);
// }
// console.log(numFloor(15.65));
// =============================================================================
// 3. ChainableClass
// Создай класс "ChainableCalculator", который позволяет вызывать методы цепочкой и получать результат.
// Пример:
// const calc = new ChainableCalculator();
// calc.add(5).subtract(2).multiply(3).result(); // 9
// class ChainableCalculator {
// 	constructor() {
// 		this._result = 0;
// 	}
// 	add(num) {
// 		this._result = this._result + num;
// 		return this;
// 	}
// 	subtract(num) {
// 		this._result = this._result - num;
// 		return this;
// 	}
// 	multiply(num) {
// 		this._result = this._result * num;
// 		return this;
// 	}
// 	division(num) {
// 		this._result = this._result / num;
// 		return this;
// 	}
// 	result() {
// 		return this._result;
// 	}
// }
// const calc = new ChainableCalculator();
// let x = calc.add(5).subtract(2).multiply(3).result();
// console.log(x)
// =============================================================================
// 4. Object.assign и прототипы
// В чём разница между поверхностным и глубоким копированием объектов? Как это связано с Object.assign?
// Поверхностное копирование (shallow): копируются только верхние уровни объекта. Вложенные объекты передаются по ссылке.
// Глубокое копирование (deep): создаются новые копии всех вложенных объектов, вплоть до самого глубоко вложенного уровня.
// Object.assign делает поверхностную копию
// Object.assign копирует только значения, а не геттеры, сеттеры, методы с дескрипторами.
// Реализуй глубокое копирование объекта без использования JSON.stringify.
// function deepClone(obj, map = new WeakMap()) {
// 	if (obj === null || typeof obj === "object") return obj;
// 	if (map.has(obj)) return map.get(obj);
// 	const clone = Array.isArray(obj) ? [] : {};
// 	map.set(obj, clone);
// 	for (const key in obj) {
// 		if (obj.hasOwnProperty(key))
// 			clone[key] = deepClone(obj[key], map);
// 	}
// 	return clone;
// }
// Напиши пример, где использование Object.assign приводит к неожиданным результатам.
// const target = { a: 1 };
// const source = {
// 	get b() {
// 		return 2;
// 	}
// };
// Object.assign(target, source);
// console.log(target);
// =============================================================================
// 5. Прототипное наследование
// Как создать объект без прототипа?
// const obj = Object.create(null);
// // Напиши функцию, которая создаёт новый объект, наследующий свойства другого объекта.
// function createObject(proto){
// 	return Object.create(proto);
// }
// Объясни разницу между proto и prototype.
// prototype — свойство функции-конструктора, объект, из которого наследуют все созданные через неё экземпляры.
// __proto__ — внутреннее свойство объекта, указывающее на объект-прототип, от которого он наследует свойства и методы.
// =============================================================================
// 6. Миксины
// Что такое миксин? Для чего он нужен?
// Миксин — это объект или класс, содержащий методы, которые могут быть добавлены в другие классы или объекты. Миксины позволяют "подмешивать" функционал в другие классы, избегая жёсткой наследственной иерархии
// Напиши миксин EventMixin, который добавляет функционал подписки и вызова событий.
// class EventMixin {
// 	constructor() {
// 		this._eventHandlers = {};
// 	}
// 	on(eventName, handler) {
// 		if (!this._eventHandlers[eventName])
// 			this._eventHandlers[eventName] = [];
// 		this._eventHandlers[eventName].push(handler);
// 	}
// 	off(eventName, handler) {
// 		if (!this._eventHandlers[eventName]) return;
// 		this._eventHandlers[eventName] = this._eventHandlers[eventName].filter(h => h !== handler);
// 	}

// 	trigger(eventName, ...args) {
// 		if(!this._eventHandlers[eventName]) return;
// 		this._eventHandlers[eventName].forEach(handler => handler.apply(this, args));
// 	}
// }
// Как можно сделать миксины безопасными для конфликтующих методов?
// Проверять, не существует ли уже метод с таким именем в целевом объекте перед добавлением, чтобы не перезаписать важную логику
// Использовать префиксы для методов миксина, чтобы уменьшить шанс конфликта (например, eventOn, eventOff).
// Можно применять символы (Symbol) для создания уникальных ключей в миксинах.
// Использовать функции-обёртки или прокси для аккуратного добавления функционала.
// =============================================================================
// 7. Множественное наследование
// Как реализовать множественное наследование в JavaScript?
// Через extends не получится потому что только одиночное наследование подерживается в js
// Напиши класс, который наследует методы из двух других классов.
// class Jumpable {
// 	jump() {
// 		console.log("Прыгает!");
// 	}
// }
// class Runnable {
// 	run() {
// 		console.log("Бежит!");
// 	}
// }
// class Hero {
// 	constructor(name) {
// 		this.name = name;
// 	}
// }
// // Добавим методы из Jumpable и Runnable в прототип Hero
// Object.assign(Hero.prototype, Jumpable.prototype, Runnable.prototype);
// =============================================================================
// 8. Замыкания
// Что такое замыкание? Приведи пример.
// Напиши функцию createCounter, которая создаёт независимый счётчик.
// Как замыкания помогают скрывать внутренние данные?
// При первичном вызове функции создается counter = 0; а дальше мы работаем с данной
// переменной не имея доступа напрямую
// const createCounter = () => {
// 	let counter = 0;
// 	return () => {
// 		counter++;
// 		return counter;
// 	};
// };
// const counter = createCounter();
// console.log(counter());//1
// console.log(counter());//2
// console.log(counter());//3
// =============================================================================
// 9. Proxy
// Что такое Proxy в JavaScript? Для чего он используется?
// Объект Proxy оборачивается вокруг другого объекта и может перехватывать (и, при желании, самостоятельно обрабатывать) разные действия с ним, например чтение/запись свойств и другие
// Реализуй Proxy, который блокирует доступ к свойствам объекта, начинающимся на "_".
// const blockUnderscoreProxy = (target) => {
// 	return new Proxy(target, {
// 		get(obj, prop) {
// 			if (typeof prop === "string" && prop.startsWith("_"))
// 				throw new Error("Доступ к свойству " + prop + " запрещен");
// 			return obj[prop];
// 		},
// 		set(obj, prop, value) {
// 			if (typeof prop === "string" && prop.startsWith("_"))
// 				throw new Error("Запрет на запись свойства " + prop);
// 			obj[prop] = value;
// 			return true;
// 		},
// 		deleteProperty(obj, prop) {
// 			if (typeof prop === "string" && prop.startsWith("_"))
// 				throw new Error("Удаление свойства " + prop + " запрещено");
// 			return delete obj[prop];
// 		}
// 	});
// };
// const obj = {
// 	_secret: 42,
// 	public: "Hello"
// }
// const proxyObj = blockUnderscoreProxy(obj);
// console.log(proxyObj.public);
// // console.log(proxyObj._secret);
// // proxyObj._secret = 43;
// // delete proxyObj._secret;
// Как использовать Proxy для логирования вызовов методов объекта?
// Незнаю если честно...но давай так логически...можно использовать get и перехватывать до выполнения
// и после выполнения кода типа как ловушка и будет работать как декораторы :)
// =============================================================================
// 10. call, apply, bind
// Как работает call, apply и bind? В чём между ними разница?
// Методы call, apply и bind позволяют управлять значением this при вызове функции. Все они принадлежат объекту Function.prototype и используются для явного указания контекста this
// call - Вызывает функцию немедленно, передавая this и аргументы по очереди.
// apply - То же самое, что call, но аргументы передаются массивом.
// bind - Не вызывает функцию сразу, а возвращает новую функцию с привязанным this и (опционально) аргументами.
// Как реализовать собственный метод bind?
// Function.prototype.myBind = function (context, ...boundArgs) {
// 	const originalFn = this;
// 	return function (...args) {
// 		return originalFn.apply(context, [...boundArgs, ...args]);
// 	};
// };
// Напиши пример использования call для заимствования метода из другого объекта.
// const arrayLike = {
// 	0: "apple",
// 	1: "banana",
// 	length: 2
// }
// Array.prototype.push.call(arrayLike, "cherry");
// console.log(arrayLike);
// =============================================================================
// 11. BigInt
// Что такое BigInt? Как он отличается от Number?
// Bigint является в js типом данных и в отличие от Number который юзает
// безопасные числа 2^53 - 1 в данном пределе Bigint ограничен только памятью
// Почему не стоит использовать Math методы с BigInt?
// Math класс преднозначен для работы с типом данных Number
// Реализуй функцию сложения двух BigInt значений.
// function bigIntSum(b1,b2){
// 	big1 = typeof b1 === "bigint" ? b1 : BigInt(b1);
// 	big2 = typeof b2 === "bigint" ? b2 : BigInt(b2);
// 	return big1+big2;
// }
// console.log(bigIntSum(100n,100n));
// =============================================================================
// Устные вопросы
// =============================================================================
// Что такое setImmediate и как оно отличается от process.nextTick?
// process.nextTick - является микротаской и выполняется до всего и вся и стоит как самая приоритетная задача
// ну по крайней мере выше промисов
// setImmediate - является макротаской и выполняется только тогда когда нет задач с I/O и выполняется первее
// чем timeout или interval
// =============================================================================
// Что произойдёт, если в замыкании изменить переменную из родительской области?
// Так как значение находится в видимости самого замыкания т.е радительской области
// то соответственно значение действительно поменяется и все будет окей
// =============================================================================
// Почему миксины могут создавать конфликты?
// Миксины могут создавать конфликты, потому что они копируют методы и свойства в объект или класс, и если там уже есть методы с такими именами, происходит перезапись.
// =============================================================================
// В чём разница между Object.create и Object.assign?
// Object.create(proto) - Создаёт новый объект, у которого proto будет прототипом
// Object.assign(target, ...sources) - Копирует свойства из одного или нескольких объектов в target.
// =============================================================================
// Как можно превратить Proxy в мемоизированный объект?
// function heavyComputation(x) {
// 	console.log("Вычисляю для ", x);
// 	return x * x;
// }
// const memoized = new Proxy(heavyComputation, {
// 	cache: new Map(),
// 	apply(target, thisArg, args) {
// 		const key = args.join(",");
// 		if (!this.cache.has(key)) {
// 			const result = Reflect.apply(target, thisArg, args);
// 			this.cache.set(key, result);
// 		}
// 		return this.cache.get(key);
// 	}
// });
// console.time("time1")
// console.log(memoized(5));
// console.time("time2");
// console.log(memoized(5));
// console.timeEnd("time1")
// console.timeEnd("time2")
// =============================================================================
// Почему важно знать о prototype и proto?
// prototype — свойство функции-конструктора, объект, из которого наследуют все созданные через неё экземпляры.
// __proto__ — внутреннее свойство объекта, указывающее на объект-прототип, от которого он наследует свойства и методы.
// Почему это важно?
// Наследование в JavaScript построено на прототипах. Чтобы понимать, как объекты получают свойства и методы, надо знать, как работает цепочка прототипов.
// Без понимания прототипов сложно дебажить код, где свойства "исчезают" или "появляются" неожиданно.
// Это ключ к работе с классами, наследованием, расширением объектов.
// Позволяет создавать более эффективный и понятный код без копирования методов на каждый объект.
// =============================================================================
// Что такое полиморфизм и как он реализуется в JavaScript?
// Полиморфизм — это способность объектов разных типов реагировать на одинаковые вызовы методов по-своему.
// То есть, у разных объектов может быть метод с одинаковым именем, но реализованный по-разному.
// Как полиморфизм реализуется в JavaScript?
// Через прототипы и наследование — разные объекты наследуют общий метод, но могут его переопределять.
// Через duck typing — если объект "кваканье" (имеет нужный метод), его можно использовать без строгой типизации.
// =============================================================================
// Что будет, если мы изменим Array.prototype?
// Если изменить Array.prototype, то это повлияет на все массивы в вашем коде, потому что они наследуют методы и свойства именно от этого объекта.
// Что это значит?
// Можно добавить новые методы, которые будут доступны во всех массивах.
// Можно изменить (перезаписать) существующие методы, что может привести к неожиданным ошибкам.
// Такой подход часто называют "патчингом" или "монкипатчингом" и он может ломать сторонние библиотеки или собственный код.
// =============================================================================
// Как работает JSON.stringify с BigInt?
// JSON.stringify не поддерживает напрямую BigInt.
// const obj = { big: 10n };
// JSON.stringify(obj);
// TypeError: Do not know how to serialize a BigInt
// Решение такой преобразовать BigInt в строку перед сериализацией
// const obj = { big: 10n };
// const json = JSON.stringify(obj, (key, value) =>
// 	typeof value === 'bigint' ? value.toString() : value
// );
// console.log(json);
// =============================================================================
// Почему опасно использовать "new" без проверки?
// Если функция-конструктор вызывается без new, то:
// this внутри функции будет либо undefined (в 'use strict'), либо укажет на глобальный объект (window в браузере).
// В результате свойства и методы могут записаться в глобальный объект, что приведёт к ошибкам и утечкам данных.
// Решение такое
// if (!(this instanceof User)) {
//     return new User(name);
// }
// делать проверку типа если вызван без new тогда возращаем принудительно
// =============================================================================